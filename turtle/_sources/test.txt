.. 
    /*
     *  test.txt
     *
     *  Testing strategy for the assignment. This file is written in reStructuredText format for Sphinx (http://sphinx.pocoo.org).
     *
     *  Author: Kenneth Kam <kk4053@bris.ac.uk>
     *  Username: kk4053
     *  Declaration: This code for COMSM1201 is the original work of Kenneth Kam.
     */
     
================================
Turtle Graphics Testing Strategy
================================

Running the automated unittests
===============================

This is as simple as:

.. code-block:: bash
    
    $ make all
    $ ./run_tests.sh
    # ./run_tests.sh -v for verbose mode

Introduction
============

A mixture of white and black box testing have been used. Unittests have been written for parsing and interpreting functions, which account for 100% of the code of the parser and interpreter. In addition, the ``parse`` and ``interp`` executables are tested manually following a test plan outlined below in `Manual Testing`_.

The tests have not been appended here as they are 
        
Unittests
=========

The unittests use the `MinUnit testing suite <http://www.jera.com/techinfo/jtns/jtn002.html>`_ which provides 2 macros: running tests and assertions. The unittests take advantage of this and test every possible path through the functions of the code by supplying different input values and asserting output values is equal to the expected values. The author believes the automated unittests have 95 to 99% code coverage. The remaining percent that cannot be automatically tested would be ``printf()`` and ``fprintf()`` statements, which appear during the unittests if the ``-v`` flag is supplied to ``run_tests.sh`` or if the tests executables are ran individually. These print statements were checked manually to ensure they were called when they are supposed to.

There are 4 test executables. ``test_parser.c`` and ``test_interpreter.c`` are the main unittest programs that do most of the testing. The unittests for the parser is straight forward and tests correct and incorrect values, while the tests for interpreter also tests the output written to the file to ensure the correct postscript commands are written.

``test_FOO_malloc.c`` are used for simulating and testing when ``malloc()`` fails. This works because there is an ``intercept.h`` file that is essentially a macro that replaces ``malloc()`` with ``my_malloc()``, which lives in ``overrides.c``. This is switched on at compile time using the ``-D`` flag in ``gcc``. Since ``my_malloc()`` is a custom function, it can be made to fail whenever the tests require it, hence the ability to test various lines of code where ``malloc()`` appears.

As well as testing for ``malloc``, the unittests contain tests for ``parse_main()`` and ``interp_main()`` and runs various fixture files that live in the ``data`` folder. ``testdata1.txt`` tests the normal set of grammar as well as nested loops and reverse loops. ``testdata2.txt`` and ``testdata3.txt`` are copied from the assignment sheet. The generated postscript file has the same shape and appearance as the one on the assignment sheet as well. However, the unittests use these as regression tests, to make sure any addition of code has not broken anything.

Other files that live in the folder are expected output files and bad input files. The bad input files are by no means exhaustive, as these have already been carefully tested in the unittests themselves. However, they serve as a kind of black box test to ensure that everything works from the top-down.

Manual Testing
==============

As well as the unittests, a few steps of manual black box testing were followed to ensure the executables behaved as expected. Although unittests provide great flexibility in terms of regression testing and ensuring the units work, it does not validate the executable. These tests do not test the entire ``data/`` folder because it has already been done in unittests.

Testing ``parse``
-----------------

Tests
    a. ``./parse``
    b. ``./parse invalid-filename.txt``
    c. ``./parse data/testdata1.txt``
    d. ``./parse data/testb_inst.txt``
    e. ``./parse data/testb_polish.txt`` [#f1]_
    
Expected results
    a. ``"Error: Requires one argument only"`` followed by usage
    b. ``"Error: failed to open invalid-filename.txt"``
    c. ``"Successfully parsed data/testdata1.txt"``
    d. ``"Error: expected <INSTRUCTION> but got 'A 30' on line 2"`` followed by ``"Error: failed to parse data/testb_inst.txt"``
    e. ``"Successfully parsed data/testb_polish.txt"``
    
.. [#f1] The grammar is correct for a polish that is a division by zero.

Results (git commit 9861423 / tag 1.0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
All tests pass.
    
=====   ====== 
Test    Result
=====   ======
a       Pass 
b       Pass 
c       Pass
d       Pass
e       Pass
=====   ======

Testing ``interp``
------------------

Tests
    a. ``./interp``
    b. ``./interp invalid-filename.txt``
    c. ``./interp invalid-filename.txt out1.txt``
    d. ``./interp data/testdata1.txt``
    e. ``./interp data/testdata1.txt out1.txt``
    f. ``./interp data/testb_inst.txt out1.txt``
    g. ``./interp data/testb_polish.txt out1.txt``
    
Expected results
    a. ``"Error: Requires two arguments"`` followed by usage
    b. ``"Error: Requires two arguments"`` followed by usage
    c. ``"Error: failed to open invalid-filename.txt"``
    d. ``"Error: Requires two arguments"`` followed by usage
    e. ``"Successfully parsed and interpreted data/testdata1.txt"`` followed by ``"Output: out1.txt"``
    f. ``"Error: expected <INSTRUCTION> but got 'A 30' on line 2"`` followed by ``"Error: failed to parse and interpret data/testb_inst.txt"``
    g. ``"Error: division by zero in polish expression 'SET A := 4 5 5 - / ;' on line 2"`` followed by ``"Error: failed to parse and interpret data/testb_polish.txt"``
    
Results (git commit 9861423 / tag 1.0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
All tests pass.
    
=====   ====== 
Test    Result
=====   ======
a       Pass 
b       Pass 
c       Pass
d       Pass
e       Pass
f       Pass
g       Pass
=====   ======
            
